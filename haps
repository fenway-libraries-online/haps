#!/usr/bin/perl

################################################################################
package Haps;

use strict;
use warnings;

use Digest;
use Cwd;

use constant ROOT => $ENV{'HAPS_ROOT'} || '/var/local/haps';

sub usage;
sub fatal;

(our $prog = $0) =~ s{.+/}{};

my $root = '/var/local/haps';
my $repo;

Haps::app() if !caller;

# Commands

sub app {
    goto &usage if !eval q{
        use Getopt::Long qw(:config posix_default gnu_compat require_order bundling no_ignore_case);
        1;
    };
    GetOptions(
        'r|root=s' => \$root,
    ) or goto &usage;
    xchdir($root);
    goto &usage if !@ARGV;
    $repo = Haps::Repository->new('.');
    my $cmd = shift @ARGV;
    exit 0 if eval {
        &{ Haps->can("app_$cmd") or goto &usage };
        1;
    };
    (my $errmsg = $@) =~ s/\n.+//msg;
    fatal($errmsg);
}

sub app_ingest {
    my $haps = Haps->new($root);
    foreach my $dir (@ARGV) {
        print STDERR "Ingesting $dir...";
        eval {
            my $pkg = $haps->package($dir);
            $repo->ingest($pkg);
            print STDERR " Done: ", $pkg->id, "\n";
        } and next;
        print STDERR " Failed\n";
        exit 1;
    }
}

# Methods

sub new {
    my ($cls, $root) = @_;
    bless {
        'root' => $root,
    }, $cls;
}

# Functions

sub in {
    my ($dir, $code) = @_;
    my $cwd = cwd();
    xchdir($dir);
    my $ok;
    eval {
        $code->();
        chdir($cwd) or die "chdir $cwd: $!\n";
        $ok = 1;
    };
    fatal $@ if !$ok;
}

### sub random_hex_string {
###     my $buf;
###     my $fh = xopen('<', '/dev/urandom');
###     read($fh, $buf, 4) or fatal "read /dev/urandom: $!";
###     return Digest->new('MD5')->add($$, localtime, $buf)->hexdigest;
### }

sub xopen {
    my ($mode, $file) = @_;
    open my $fh, $mode, $file or fatal "open $file: $!";
    binmode $fh;
    return $fh;
}

sub xchdir {
    foreach (@_) {
        chdir $_ or fatal "chdir $_: $!";
    }
}

sub xmkdir {
    foreach (@_) {
        mkdir $_ or fatal "mkdir $_: $!";
    }
}

sub xtouch {
    foreach my $f (@_) {
        utime(undef, undef, $f) or die "utime $f: $!";
    }
}

sub xrun {
    my $descrip = shift;
    my (@out, @err);
    my ($in, $out, $err) = (
        undef,
        sub { print STDOUT @_; push @out, shift },
        sub { print STDERR @_; push @err, shift },
    );
    $in  = shift if @_ && ref $_[0];
    $out = shift if @_ && ref $_[0];
    $err = shift if @_ && ref $_[0];
    fatal "huh?" if !@_;
    my $ret = run3([@_], $in, $out, $err) || $?;
    return $ret if !wantarray;
    return ($ret, \@out, \@err);
}

sub usage {
    print STDERR "usage: $prog COMMAND [ARG...]\n";
    exit 1;
}

sub fatal {
    print STDERR "$prog: @_\n";
    exit 2;
}

################################################################################
package Haps::Package;

sub new {
    my $cls = shift;
    bless { @_ }, $cls;
}

sub id {
    my ($self) = @_;
    return $self->{'id'} if $self->{'id'};
    my $fh = xopen('<', $self->root . '/md5.sum');
    my $md5 = Digest->new('MD5')->addfile($fh)->hexdigest;
    return $self->{'id'} = lc $md5;
}

sub check {
    my ($self, $md5deep) = @_;
    Haps::in($self->root, sub {
        die 'required file is missing: md5.sum' if !-e 'md5.sum';
        foreach (qw(files metadata haps/v1)) {
            die "required directory is missing: $_" if !-d $_;
        }
        my @haps   = glob('haps/*');
        my @hapsv1 = glob('haps/v1/*');
        my @files  = glob('files/*');
        die 'haps/ must not contain anything besides v1' if @haps > 1;
        die 'haps/v1/ must be empty' if @hapsv1;
        die 'files/ must not be empty' if !@files;
        die 'required file is missing: metadata/metadata.txt or metadata/descrip.txt'
            if !-e 'metadata/metadata.txt' && !-e 'metadata/descrip.txt';
        if ($md5deep) {
            my ($ret, $out, $err) = xrun(qw(md5deep -r -Fm -x md5.sum), @files);
            die 'md5 verification failed: ', scalar(@$out), ' files'
                if $ret != 0;
        }
    });
}

################################################################################
package Haps::Repository;

sub new {
    my $cls = shift;
    unshift @_, 'root' if @_ % 2;  # $cls->create($root, ...)
    return bless { @_ }, $cls;
}

sub create {
    my ($cls, $root) = @_;
    die "usage: Haps::Repository->create('/path/to/repo/root')" if @_ != 2;
    my $self = $cls->new('root' => $root);
    if (!-d $root) {
        xmkdir($root);
    }
    else {
        my @files = glob("$root/*");
        die "root $root is not empty" if @files;
    }
    xmkdir("$root/packages", "$root/work", "$root/index", "$root/inventory");
    xtouch("$root/work/haps.log");
    return $self;
}

sub ingest {
    my ($self, $pkg) = @_;
    $pkg->check;
    my $id = $pkg->id;
    my $root = $self->root;
    my $src = $pkg->root;
    my $pfx = $self->prefix($id);
    my $tmp = "$root/work/$id";
    my $dst = "$tmp/root";
    Haps::xmkdir($tmp, $dst);
    my ($ret, $out, $err) = xrun(qw(rsync -a -v), $src.'/', $dst.'/');
    if (-e "$src/md5.sum") {
        Haps::in($dst, sub {
            xrun(qw(md5deep -r -k -Fm), "$src/md5.sum");
        });
    }
    xrename($dst, "$root/packages/$pfx/$id");
    $self->postprocess($pkg);
}

sub root { @_ > 1 ? $_[0]->{'root'} = $_[1] : $_[0]->{'root'} }

sub package {
    my $self = shift;
    return Haps::Package->new(@_);
}

sub prefix {
    my ($self, $id) = @_;
    return substr($id, 0, 3);
}

sub postprocess {
    my ($self, $pkg) = @_;
    1;
}

sub check {
    my $self = shift;
    foreach my $id (@_) {
        ;
    }
}

