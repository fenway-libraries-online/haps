#!/usr/bin/perl

package Haps;

use strict;
use warnings;

use Digest;

use constant ROOT => $ENV{'HAPS_ROOT'} || '/var/local/haps';

sub usage;
sub fatal;

(our $prog = $0) =~ s{.+/}{};

my $root = '/var/local/haps';

Haps::app() if !caller;

# Commands

sub app {
    goto &usage if !eval q{
        use Getopt::Long qw(:config posix_default gnu_compat require_order bundling no_ignore_case);
        1;
    };
    GetOptions(
        'r|root=s' => \$root,
    ) or goto &usage;
    xchdir($root);
    goto &usage if !@ARGV;
    my $cmd = shift @ARGV;
    exit 0 if eval {
        &{ Haps->can("app_$cmd") or goto &usage };
        1;
    };
    (my $errmsg = $@) =~ s/\n.+//msg;
    fatal($errmsg);
}

sub app_ingest {
    my $haps = Haps->new($root);
    foreach my $dir (@ARGV) {
        print STDERR "Ingesting $dir...";
        eval {
            my $pkg = $haps->package($dir);
            my $batch = $haps->ingest($pkg);
            print STDERR " Done: ", $batch->id, "\n";
        } and next;
        print STDERR " Failed\n";
        exit 1;
    }
}

# Methods

sub new {
    my ($cls, $root) = @_;
    bless {
        'root' => $root,
    }, $cls;
}

sub root { @_ > 1 ? $_[0]->{'root'} = $_[1] : $_[0]->{'root'} }

sub random_hex_string {
    my $buf;
    my $fh = xopen('<', '/dev/urandom');
    read($fh, $buf, 4) or fatal "read /dev/urandom: $!";
    return Digest->new('MD5')->add($$, localtime, $buf)->hexdigest;
}

sub ingest {
    my ($self, $pkg) = @_;
    $pkg->check;
    my $batch = $self->batch(
        'package' => $pkg,
    );
    my $root = $self->root;
    my $src = $pkg->root;
    my $id = $batch->id;
    my $pfx = substr($id, 0, 3);
    my $tmp = "$root/batches/tmp/$id";
    my $dst = "$tmp/root";
    xmkdir($tmp, $dst);
    my ($ret, $out, $err) = xrun(qw(rsync -a -v), $src.'/', $dst.'/');
    if (-e "$src/md5.sum") {
        xchdir($dst);
        xrun(qw(md5deep -r -k -Fm), "$src/md5.sum");
        xchdir($root);
    }
    $self->postprocess($batch);
    xrename($dst, "$root/batches/$pfx/$id");
}

sub batch {
    my $self = shift;
    return Haps::Batch->new(@_);
}

sub postprocess {
    my ($self, $batch) = @_;
    1;
}

# Functions

sub xopen {
    my ($mode, $file) = @_;
    open my $fh, $mode, $file or fatal "open $file: $!";
    return $fh;
}

sub xchdir {
    foreach (@_) {
        chdir $_ or fatal "chdir $_: $!";
    }
}

sub xrun {
    my $descrip = shift;
    my (@out, @err);
    my ($in, $out, $err) = (
        undef,
        sub { print STDOUT @_; push @out, shift },
        sub { print STDERR @_; push @err, shift },
    );
    $in  = shift if @_ && ref $_[0];
    $out = shift if @_ && ref $_[0];
    $err = shift if @_ && ref $_[0];
    fatal "huh?" if !@_;
    my $ret = run3([@_], $in, $out, $err) || $?;
    return $ret if !wantarray;
    return ($ret, \@out, \@err);
}

sub usage {
    print STDERR "usage: $prog COMMAND [ARG...]\n";
    exit 1;
}

sub fatal {
    print STDERR "$prog: @_\n";
    exit 2;
}

package Haps::Package;

sub new {
    my $cls = shift;
    bless { @_ }, $cls;
}

sub check {
    my ($self, $skip_md5deep) = @_;
    $self->in(sub {
        die 'required file is missing: md5sum.txt' if !-e 'md5sum.txt';
        foreach (qw(files metadata haps/v1)) {
            die "required directory is missing: $_" if !-d $_;
        }
        my @haps   = glob('haps/*');
        my @hapsv1 = glob('haps/v1/*');
        my @files  = glob('files/*');
        die 'haps/ must not contain anything besides v1' if @haps > 1;
        die 'haps/v1/ must be empty' if @hapsv1;
        die 'files/ must not be empty' if !@files;
        die 'required file is missing: metadata/metadata.txt or metadata/descrip.txt'
            if !-e 'metadata/metadata.txt' && !-e 'metadata/descrip.txt';
        if (!$skip_md5deep) {
            my ($ret, $out, $err) = xrun(qw(md5deep -r -Fm -x md5sum.txt), @files);
            die 'md5 verification failed: ', scalar(@$out), ' files'
                if $ret != 0;
        }
    });
}

sub in {
    my ($self, $code) = @_;
    use Cwd;
    my $cwd = cwd();
    xchdir($self->root);
    my $ok;
    eval {
        $code->();
        chdir($cwd) or die "chdir $cwd: $!\n";
        $ok = 1;
    };
    fatal $@ if !$ok;
}

package Haps::Batch;

sub new {
    my $cls = shift;
    my $self = bless { @_ }, $cls;
    $self->{'id'} ||= Haps->random_hex_string();
}

sub id { @_ > 1 ? $_[0]->{'id'} = $_[1] : $_[0]->{'id'} }
